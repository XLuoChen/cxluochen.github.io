---
title: Docker VS 虚拟机
date: 2017-11-07
tags: [Docker, 虚拟机, Linux]
categories: [运维相关]
comments: true
---

## 1. docker 是什么

![](docker_logo.jpg)

Docker 的思想来自于集装箱。例如在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那就可以用一艘大船把他们都运走。

以 docker 的 logo 来说，那个大鲸鱼（或者是货轮）就是操作系统，把要交付的应用程序看成是各种货物，原本要将各种各样形状、尺寸不同的货物放到大鲸鱼上，你得为每件货物考虑怎么安放（就是应用程序配套的环境），还得考虑货物和货物是否能叠起来（应用程序依赖的环境是否会冲突）。现在使用了集装箱（容器）把每件货物都放到集装箱里，这样大鲸鱼可以用同样地方式安放、堆叠集装了，省事省力。

<!--more-->

## 2. docker 的优势

*   **更高效的利用系统资源**

    由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，因此 Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。

*   **更快速的启动时间**

    传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。

*   **一致的运行环境**

    项目开发过程中可能有多种环境，例如开发环境、测试环境、生产环境等，环境的不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，也消除了在不同开发人员电脑上的环境变异性。

*   **持续交付和部署**

    我们可以使用 Dockerfile 定制应用镜像，因此运维人员可以在生产环境中直接部署该镜像，甚至自动部署。

*   **更轻松的迁移**

    由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。

*   **更轻松的维护和扩展**

    Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。

## 3. 基本概念

### 镜像（imgae）

Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。

镜像不包含任何动态数据，其内容在构建之后也不会被改变。

**分层存储**

镜像并非由一个文件组成而是一组文件并分层级管理，每一层都基于上一层，所有的修改都是对本层级而言的，不会改变之前的层级。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。

### 容器（container）

**镜像和容器的关系**

容器是镜像运行的一个实例。类比类和实例，镜像是静态的定义，容器是镜像运行时的实体。

容器的实质是进程，但是有别于宿主机上的进程，它可以拥有自己的命名空间，文件系统等，容器内的进程运行在一个隔离的环境里，用起来就好像是在一个独立于宿主的系统下操作一样。

容器运行时也会使用分层存储，每一个容器运行时都会基于镜像在其上创建一个容器存储层，
该存储层与容器共存亡。

### 仓库（repo）

**使用仓库的原因：**

**提供集中的存储、分发镜像的服务（docker registry），使得镜像可以运行在其他服务器上。**

镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。

一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。

通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。以 Ubuntu 镜像为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，14.04, 16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。

仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。

**最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。**

## 4. docker 和 虚拟机思想上的区别

![](architecture.jpg)

### 虚拟机

传统的虚拟机需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给他的资源将全部被占用。，每一个虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。

### docker

容器技术是和我们的宿主机共享硬件资源及操作系统可以实现资源的动态分配。
容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。

对于容器，它首先是一个相对独立的运行环境，在这一点有点类似于虚拟机，但是不像虚拟机那样彻底。在容器内，应该最小化其对外界的影响，比如不能在容器内把宿主机上的资源全部消耗，这就是资源控制。

> 容器和虚拟机之间的主要区别在于虚拟化层的位置和操作系统资源的使用方式。

容器与虚拟机拥有着类似的使命：对应用程序及其关联性进行隔离，从而构建起一套能够随处运行的自容纳单元。此外，容器与虚拟机还摆脱了对物理硬件的需求，允许我们更为高效地使用计算资源，从而提升能源效率与成本效益。

### 主要区别

虚拟机会将虚拟硬件、内核（即操作系统）以及用户空间打包在新虚拟机当中，虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。虚拟机依赖于 hypervisor，其通常被安装在“裸金属”系统硬件之上，这导致hypervisor 在某些方面被认为是一种操作系统。一旦 hypervisor 安装完成， 就可以从系统可用计算资源当中分配虚拟机实例了，每台虚拟机都能够获得唯一的操作系统和负载(应用程序)。简言之，虚拟机先需要虚拟一个物理环境，然后构建一个完整的操作系统，再搭建一层 Runtime，然后供应用程序运行。

对于容器环境来说，不需要安装主机操作系统，直接将容器层(比如LXC或libcontainer)安装在主机操作系统(通常是Linux变种)之上。在安装完容器层之后，就可以从系统可用计算资源当中分配容器实例了，并且企业应用可以被部署在容器当中。但是，每个容器化应用都会共享相同的操作系统(单个主机操作系统)。容器可以看成一个装好了一组特定应用的虚拟机，它直接利用了宿主机的内核，抽象层比虚拟机更少，更加轻量化，启动速度极快。

### 举例说明

**服务器好比运输码头**：拥有场地和各种设备（服务器硬件资源）

**虚拟机好比作码头上的仓库**：拥有独立的空间堆放各种货物或集装箱(仓库之间完全独立，独立的应用系统和操作系统）

**Docker比作集装箱**：各种货物的打包(将各种应用程序和他们所依赖的运行环境打包成标准的容器,容器之间隔离)

Docker有着小巧、迁移部署快速、运行高效等特点，但隔离性比服务器虚拟化差：不同的集装箱属于不同的运单（Docker上运行不同的应用实例），相互独立（隔离）。但由同一个库管人员管理（主机操作系统内核），因此通过库管人员可以看到所有集装箱的相关信息（因为共享操作系统内核，因此相关信息会共享）。

虚拟机就好比在码头上（物理主机及虚拟化层），建立了多个独立的“小码头”—仓库。其拥有完全独立（隔离）的空间，属于不同的客户（虚拟机所有者）。每个仓库有各自的库管人员（当前虚拟机的操作系统内核），无法管理其它仓库。不存在信息共享的情况。

如果还是不太理解，可以参照下图。

**物理机**

![](physical_machine.jpg)

**虚拟机**

![](virtual_machine.jpg)

**容器**

![](container.jpg)

